import sys,os
import math
import re
import dash_cytoscape as cyto
import networkx as nx
from util.color_manager import StandardPalette
from rdflib.namespace import RDF


class AbstractVisualiser:
    def __init__(self):
        cyto.load_extra_layouts()
        self.pos = []
        self.mode = self.set_network_mode
        self.layout = self.set_spring_layout
        self.node_text_preset = self.add_node_no_labels
        self.edge_text_preset = self.add_edge_no_labels
        self.node_color_preset = self.add_standard_node_color
        self.edge_color_preset = self.add_standard_edge_color
        self.node_size_preset = self.add_standard_node_size

        self.elements = []
        self._standard_node_size = 30
        self._node_text_size = 3
        self._edge_text_size = 5
        self._node_shape_preset = self.set_circle_node_shape
        self.edge_shape = "straight"
        self.cyto_shapes = ["circle",
                            "square",
                            "triangle",
                            "rectangle",
                            "diamond",
                            "hexagon",
                            "octagon",
                            "vee",
                            "parallelogram",
                            "roundrect",
                            "ellipse"]


    def copy_settings(self):
        current_settings = [
            self.layout,
            self.node_text_preset,
            self.edge_text_preset,
            self.node_color_preset,
            self.edge_color_preset,
        ]

        return current_settings

    # ---------------------- Set Preset (Sets one or more other settings to focus on a specific thing in the graph) ----------------------
    def _set_preset(self,functions):
        for func in functions:
            func()
        return functions

    
    # ---------------------- Set Mode (Type of graph) ------------------------------------
    def set_network_mode(self):
        '''
        Set the graph to the standard Node-Edge-Node Network graph.
        Duplicates are merged into the same node leading to connectedness.
        '''
        if self.mode == self.set_network_mode:
            self.graph_view = self.graph_view.get_network()
        else:
            self.mode = self.set_network_mode

    def set_tree_mode(self):
        '''
        Produce a Tree-Like graph where duplicates within 
        the graph are NOT treated as the same node.
        This will result in a tree/heirarchy structure within a graph.
        '''
        if self.mode == self.set_tree_mode:
            self.graph_view = self.graph_view.get_tree()
        else:
            self.mode = self.set_tree_mode

    
    def set_full_graph_view(self):
        '''
        Renders the Full graph. 
        Default option.
        '''
        self.graph_view = self._graph.produce_full_graph()

    # ---------------------- Pick a layout ----------------------
    def set_spring_layout(self):
        '''
        Position nodes using Fruchterman-Reingold force-directed algorithm.
        '''
        if self.layout == self.set_spring_layout:
            self.pos = nx.spring_layout(self.graph_view.graph, iterations=200)
        else:
            self.layout = self.set_spring_layout

    def set_circular_layout(self):
        '''
        Position nodes on a circle.
        '''
        if self.layout == self.set_circular_layout:
            self.pos = nx.circular_layout(self.graph_view.graph)
        else:
            self.layout = self.set_circular_layout

    def set_kamada_kawai_layout(self):
        '''
        Position nodes using Kamada-Kawai path-length cost-function.
        '''
        if self.layout == self.set_kamada_kawai_layout:
            self.pos = nx.kamada_kawai_layout(self.graph_view.graph)
        else:
            self.layout = self.set_kamada_kawai_layout

    def set_planar_layout(self):
        '''
        Position nodes without edge intersections.
        '''
        if self.layout == self.set_planar_layout:
            self.pos = nx.planar_layout(self.graph_view.graph)
        else:
            self.layout = self.set_planar_layout

    def set_no_layout(self):
        '''
        No new positional data produced for graph.
        '''
        if self.layout == self.set_no_layout:
            self.pos = None
            return {"name" : "preset"}
        else:
            self.layout = self.set_no_layout

    def set_concentric_layout(self):
        '''
        Position nodes into concentric circles, 
        based on the specified metric. 
        '''
        if self.layout == self.set_concentric_layout:
            self.pos = None
            return {"name" : "concentric"}
        else:
            self.layout = self.set_concentric_layout

    def set_breadthfirst_layout(self):
        '''
        Positions nodes in levels, according to the levels 
        generated by running a breadth-first search on the graph.
        '''
        if self.layout == self.set_breadthfirst_layout:
            self.pos = None
            return {"name" : "breadthfirst",
                    'directed': True,}
        else:
            self.layout = self.set_breadthfirst_layout

    def set_cose_layout(self):
        '''
        Positions nodes based on the CoSE: Compound Spring Embedder - 
        A force directed layout scheme.
        '''
        if self.layout == self.set_cose_layout:
            self.pos = None
            return {"name" : "cose",
                    'idealEdgeLength': 100,
                    'nodeOverlap': 20,
                    'refresh': 20,
                    'fit': True,
                    'padding': 30,
                    'randomize': False,
                    'componentSpacing': 100,
                    'nodeRepulsion': 400000,
                    'edgeElasticity': 100,
                    'nestingFactor': 5,
                    'gravity': 80,
                    'numIter': 1000,
                    'initialTemp': 200,
                    'coolingFactor': 0.95,
                    'minTemp': 1.0}
        else:
            self.layout = self.set_cose_layout

    def set_cose_bilkent_layout(self):
        '''
        Positions nodes based on the CoSE: Compound Spring Embedder - 
        A force directed layout scheme.
        Similar to COSE but more expensive + can provide better results.
        '''
        if self.layout == self.set_cose_bilkent_layout:
            self.pos = None
            return {"name" : "cose-bilkent"}
        else:
            self.layout = self.set_cose_bilkent_layout

    def set_cola_layout(self):
        '''
        Positions nodes based on a force directed algorithm.
        '''
        if self.layout == self.set_cola_layout:
            self.pos = None
            return {"name" : "cola"}
        else:
            self.layout = self.set_cola_layout

    def set_euler_layout(self):
        '''
        Positions nodes based on a force directed algorithm.
        It is fairly fast. However, cola tends to give better results.
        '''
        if self.layout == self.set_euler_layout:
            self.pos = None
            return {"name" : "euler"}
        else:
            self.layout = self.set_euler_layout

    def set_spread_layout(self):
        '''
        Positions nodes based on a force directed algorithm.
        First, it runs cose and then it spreads out the graph 
        to fill out the viewport as much as possible.
        '''
        if self.layout == self.set_spread_layout:
            self.pos = None
            return {"name" : "spread"}
        else:
            self.layout = self.set_spread_layout

    def set_dagre_layout(self):
        '''
        Positions nodes based on a traditional binary tree heirarchical layout.
        '''
        if self.layout == self.set_dagre_layout:
            self.pos = None
            return {"name" : "dagre"}
        else:
            self.layout = self.set_dagre_layout

    def set_klay_layout(self):
        '''
        Positions nodes based on a heirarchical layout.
        '''
        if self.layout == self.set_klay_layout:
            self.pos = None
            return {"name" : "klay"}
        else:
            self.layout = self.set_klay_layout
   
    def set_grid_layout(self):
        '''
        Positions nodes based on a heirarchical layout.
        '''
        if self.layout == self.set_grid_layout:
            self.pos = None
            return {"name" : "grid"}
        else:
            self.layout = self.set_grid_layout
   
    # ---------------------- Pick the node content ----------------------
    def add_node_no_labels(self):
        '''
        Textual data pertaining to a node is not rendered.
        '''
        if self.node_text_preset == self.add_node_no_labels:
            return [None] * len(self.graph_view.nodes())
        else:
            self.node_text_preset = self.add_node_no_labels

    def add_node_adjacency_labels(self):
        '''
        Textual data pertaining to a node relates 
        to number of incoming and outgoing edges.
        '''
        if self.node_text_preset == self.add_node_adjacency_labels:
            node_text = []
            for node in self.graph_view.nodes:
                num_in = len(self.graph_view.in_edges(node))
                num_out = len(self.graph_view.out_edges(node)) 
                node_text.append(f"# IN: {str(num_in)}, # OUT: {str(num_out)}")
            return node_text
        else:
            self.node_text_preset = self.add_node_adjacency_labels

    def add_node_name_labels(self):
        '''
        Textual data pertaining to a node relates to the 
        name the node was provided during building of the graph.
        '''
        if self.node_text_preset == self.add_node_name_labels:
            node_text = []
            names = nx.get_node_attributes(self.graph_view,"display_name")
            for v in names.values():
                node_text.append(v)
            return node_text
        else:
            self.node_text_preset = self.add_node_name_labels

        
    def add_node_type_labels(self):
        '''
        Textual data pertaining to a node is of the RDF type.
        '''
        if self.node_text_preset == self.add_node_type_labels:
            node_text = []
            for node in self.graph_view.nodes:
                for n,v,e in self._graph.edges(node,keys=True):
                    if e[1] == RDF.type:
                        node_text.append(self._get_name(str(e[2])))
                        break
                else:
                    # I think this should only be literals and external identifiers.
                    if isinstance(e[2],Literal):
                        node_text.append("Literal")
                    elif isinstance(e[2],URIRef):
                        node_text.append("Identifier")
                    else:
                        node_text.append("?")
            return node_text
        else:
            self.node_text_preset = self.add_node_type_labels

            

    # ---------------------- Pick the node color ----------------------
    def add_standard_node_color(self):
        '''
        All node colors are the same standard color.
        '''
        if self.node_color_preset == self.add_standard_node_color:
            return [{"standard" : StandardPalette.primary.value} for node in self.graph_view.nodes()]
        else:
            self.node_color_preset = self.add_standard_node_color

    def add_rdf_type_node_color(self):
        '''
        Dual color, Objects and Properties have a unique color.
        '''
        if self.node_color_preset == self.add_rdf_type_node_color:
            colors = []
            for node,data in self.graph_view.nodes(data=True):
                if self._graph.graph.get_rdf_type(node) is not None:
                    color = {"rdf_type" : StandardPalette.primary.value}
                else:
                    color = {"no_type" : StandardPalette.secondary.value}
                colors.append(color)
            return colors
        else:
            self.node_color_preset = self.add_rdf_type_node_color

    # ---------------------- Set Node Size ----------------------
    def add_standard_node_size(self):
        '''
        The Node size for each node is equal.
        '''
        if self.node_size_preset == self.add_standard_node_size:
            return [self._standard_node_size for node in self.graph_view.nodes()]
        else:
            self.node_size_preset = self.add_standard_node_size

    def add_type_node_size(self):
        '''
        The Node size for each node is based on whether it is 
        a Object or a property i.e. does the node has an RDF type.
        '''
        if self.node_size_preset == self.add_type_node_size:
            node_sizes = []
            for node in self.graph_view.nodes():
                if self._graph.graph.get_rdf_type(node) is None:
                    node_sizes.append(self._standard_node_size/2)
                else:
                    node_sizes.append(self._standard_node_size)
            return node_sizes
        else:
            self.node_size_preset = self.add_type_node_size

    def add_centrality_node_size(self):
        '''
        The Node size is greater the more 
        incoming + outgoing edges of said node. 
        '''
        if self.node_size_preset == self.add_centrality_node_size:
            node_sizes = []
            for index,node in enumerate(self.graph_view.nodes()):
                node_size = 1 + len(self.graph_view.in_edges(node)) + len(self.graph_view.out_edges(node))
                node_size = int((node_size * self._standard_node_size) / 4)
                if node_size > 100:
                    node_size = 100
                if node_size < self._standard_node_size/2:
                    node_size = self._standard_node_size
                node_sizes.append(node_size)
            return node_sizes
        else:
            self.node_size_preset = self.add_centrality_node_size


    def add_in_centrality_node_size(self):
        '''
        The Node size is greater the more 
        incoming edges of said node. 
        '''
        if self.node_size_preset == self.add_in_centrality_node_size:
            node_sizes = []
            for index,node in enumerate(self.graph_view.nodes()):
                node_size = 1 + len(self.graph_view.in_edges(node))
                node_size = int((node_size * self._standard_node_size) / 2)
                if node_size > 100:
                    node_size = 100
                if node_size < self._standard_node_size/2:
                    node_size = self._standard_node_size
                node_sizes.append(node_size)
            return node_sizes
        else:
            self.node_size_preset = self.add_in_centrality_node_size


    def add_out_centrality_node_size(self):
        '''
        The Node size is greater the more 
        outgoing edges of said node. 
        '''
        if self.node_size_preset == self.add_out_centrality_node_size:
            node_sizes = []
            for index,node in enumerate(self.graph_view.nodes()):
                node_size = 1 + len(self.graph_view.out_edges(node))
                node_size = int((node_size * self._standard_node_size) / 2)
                if node_size > 100:
                    node_size = 100
                if node_size < self._standard_node_size/2:
                    node_size = self._standard_node_size
                node_sizes.append(node_size)
            return node_sizes
        else:
            self.node_size_preset = self.add_out_centrality_node_size
        
    # ---------------------- Pick the edge color ----------------------
    def add_standard_edge_color(self):
        '''
        The color pertaining to each edge is uniform. 
        '''
        if self.edge_color_preset == self.add_standard_edge_color:
            return [{"standard" : "#888"} for e in self.graph_view.edges]
        else:
            self.edge_color_preset = self.add_standard_edge_color

    


    # ---------------------- Pick the edge content ----------------------
    def add_edge_no_labels(self):
        '''
        Textual data pertaining to a egde is not rendered.
        '''
        if self.edge_text_preset == self.add_edge_no_labels:
            return [None] * len(self.graph_view.edges())
        else:
            self.edge_text_preset = self.add_edge_no_labels

    def add_edge_name_labels(self):
        '''
        Textual data pertaining relates to the 
        name provides when building the graph.
        '''
        if self.edge_text_preset == self.add_edge_name_labels:
            edge_names = []
            for edge in self.graph_view.edges(data=True):
                edge_names.append(edge[2]["display_name"])
            return edge_names
        else:
            self.edge_text_preset = self.add_edge_name_labels

    
    # ---------------------- Set Node Shape ----------------------

    def set_adaptive_node_shape(self):
        '''
        Sets the shape of each node based on the RDF type of given node.
        '''
        if self._node_shape_preset == self.set_adaptive_node_shape:
            default_shape = self.cyto_shapes[0]
            cyto_shapes = self.cyto_shapes[1:]
            node_shapes = []
            shape_map = {"no_type" : default_shape}
            counter = 0
            nodes = self.graph_view.nodes()
            for node in nodes:
                obj_type = self._graph.graph.get_rdf_type(node)
                if obj_type is None:
                    shape = shape_map["no_type"]
                    obj_type = "No Type"
                else:
                    obj_type = self._get_name(obj_type[1]["key"])
                    if obj_type in shape_map.keys():
                        shape = shape_map[obj_type]
                    else:
                        shape = cyto_shapes[counter]
                        shape_map[obj_type] = shape
                        if counter == len(cyto_shapes):
                            counter = 0
                        else:
                            counter = counter + 1 
                node_shapes.append({obj_type : shape})
            return node_shapes
        else:
            self._node_shape_preset = self.set_adaptive_node_shape

    def set_circle_node_shape(self):
        '''
        Sets the shape of each node to a circle.
        '''
        if self._node_shape_preset == self.set_circle_node_shape:
            return [{"standard" : "circle"} for node in self.graph_view.nodes]
        else:
            self._node_shape_preset = self.set_circle_node_shape

    def set_square_node_shape(self):
        '''
        Sets the shape of each node to a square.
        '''
        if self._node_shape_preset == self.set_square_node_shape:
            return [{"standard" : "square"} for node in self.graph_view.nodes]
        else:
            self._node_shape_preset = self.set_square_node_shape

    def set_triangle_node_shape(self):
        '''
        Sets the shape of each node to a triangle.
        '''
        if self._node_shape_preset == self.set_triangle_node_shape:
            return [{"standard" : "triangle"} for node in self.graph_view.nodes]
        else:
            self._node_shape_preset = self.set_triangle_node_shape

    def set_rectangle_node_shape(self):
        '''
        Sets the shape of each node to a rectangle.
        '''
        if self._node_shape_preset == self.set_rectangle_node_shape:
            return [{"standard" : "rectangle"} for node in self.graph_view.nodes]
        else:
            self._node_shape_preset = self.set_rectangle_node_shape

    def set_diamond_node_shape(self):
        '''
        Sets the shape of each node to a diamond.
        '''
        if self._node_shape_preset == self.set_diamond_node_shape:
            return [{"standard" : "diamond"} for node in self.graph_view.nodes]
        else:
            self._node_shape_preset = self.set_diamond_node_shape

    def set_hexagon_node_shape(self):
        '''
        Sets the shape of each node to a hexagon.
        '''
        if self._node_shape_preset == self.set_hexagon_node_shape:
            return [{"standard" : "hexagon"} for node in self.graph_view.nodes]
        else:
            self._node_shape_preset = self.set_hexagon_node_shape

    def set_octagon_node_shape(self):
        '''
        Sets the shape of each node to a octagon.
        '''
        if self._node_shape_preset == self.set_octagon_node_shape:
            return [{"standard" : "octagon"} for node in self.graph_view.nodes]
        else:
            self._node_shape_preset = self.set_octagon_node_shape
            
    def set_vee_node_shape(self):
        '''
        Sets the shape of each node to a vee.
        '''
        if self._node_shape_preset == self.set_vee_node_shape:
            return [{"standard" : "vee"} for node in self.graph_view.nodes]
        else:
            self._node_shape_preset = self.set_vee_node_shape
    
    
    # ---------------------- Set edge shape ----------------------
    def set_straight_edge_shape(self):
        '''
        Sets the shape of each edge to a straight line.
        '''
        self.edge_shape = "straight"

    def set_bezier_edge_shape(self):
        '''
        Sets the shape of each edge to a straight line.
        Overlapping edges are curved.
        '''
        self.edge_shape = "bezier"

    def set_taxi_edge_shape(self):
        '''
        Sets the shape of each edge to a two straight 
        lines with a right angle.
        '''
        self.edge_shape = "taxi"

    def set_unbundled_bezier_edge_shape(self):
        '''
        Sets the shape of each edge based on the unbundled_bezier algorithm.
        '''
        self.edge_shape = "unbundled-bezier"
        
    def set_loop_edge_shape(self):
        '''
        Sets the shape of each edge to a loop .
        '''
        self.edge_shape = "loop"

    def set_haystack_edge_shape(self):
        '''
        Sets the shape of each edge based on the haystack algorithm.
        '''
        self.edge_shape = "haystack"

    def set_segments_edge_shape(self):
        '''
        Sets the shape of each edge to a set of segments. 
        '''
        self.edge_shape = "segments"
   
  # ---------------------- Misc Settings ---------------------
    def node_text_size(self,size = None):
        if size is None:
            return self._node_text_size
        self._node_text_size = float(size)

    def edge_text_size(self,size = None):
        if size is None:
            return self._edge_text_size
        self._edge_text_size = float(size)

    def build(self,layout_elements = {}, graph_id="cytoscape_graph", legend=False, width=100,height=100):
        elements = []
        stylesheet = []
        temp_node_selectors = []
        temp_edge_selectors = []

        self.mode()
        if self.layout != self.graph_view.graph and self.layout is not None:
            # Builtin presets will calculate the positons.
            layout = self.layout()
        elif self.pos == [] and self.pos is None:
            raise ValueError("Unable to visualise with no positional data.")
        if self.node_text_preset is not None:
            node_text = self.node_text_preset()
            stylesheet.append({'selector': 'node','style': {'content': 'data(label)',
                                                            "height" : "data(size)",
                                                            "width" : "data(size)",
                                                            "font-size" : self._node_text_size}})
        node_color = self.node_color_preset()
        node_shapes = self._node_shape_preset()
        node_sizes = self.node_size_preset()
        edge_color = self.edge_color_preset()  
        edge_text = self.edge_text_preset()
        if legend:
            legend_dict = self._build_legend(node_color,edge_color,node_shapes)

        cyto_edges = []
        cyto_nodes = []
        for index,node in enumerate(self.graph_view.nodes(data=True)):
            label = node[1]
            node = node[0]
            color_key =  list(node_color[index].keys())[0]
            node_shape = node_shapes[index]
            node_shape_value = str(list(node_shape.values())[0])
            node_size = node_sizes[index]
            try:
                parent = label["parent"]
            except KeyError:
                parent = None
            try:
                is_parent = label["is_parent"]
            except KeyError:
                is_parent = False
            if is_parent:
                cyto_node = {
                    'data': {'id': node, 'label': node_text[index],"size" : node_size, 'parent' : parent},
                    "classes" : "top-center " + "parent"}
            else:
                cyto_node = {
                    'data': {'id': node, 'label': node_text[index],"size" : node_size,'parent' : parent},
                    "classes" : "top-center " + color_key + " " + node_shape_value}

                if color_key not in temp_node_selectors:
                    stylesheet.append({"selector" : "." + color_key, "style" : {"background-color" : node_color[index][color_key]}})    
                    temp_node_selectors.append(color_key)                             

            if self.pos != [] and self.pos is not None:
                cyto_node["position"] = {'x': 2000 * self.pos[node][0], 'y': 2000 * self.pos[node][1]}
            cyto_nodes.append(cyto_node)

        stylesheet.append({'selector': 'edge','style': {'content': 'data(label)',
                                                "mid-target-arrow-color": "grey",
                                                "mid-target-arrow-shape": "triangle",
                                                "font-size" : self._edge_text_size}})        
        for index,e in enumerate(self.graph_view.edges(data=True)):
            u,v,edge  = e
            color_key =  list(edge_color[index].keys())[0]
            cyto_edge = {
                'data': {'source': u, 'target': v, 'label': edge_text[index]},
                "classes" : "center-right " + color_key}

            if color_key not in temp_edge_selectors:
                stylesheet.append({"selector" : "." + color_key,"style" : {"line-color" : edge_color[index][color_key],
                                                                            'curve-style': self.edge_shape,
                                                                            "mid-target-arrow-color": edge_color[index][color_key],
                                                                            "mid-target-arrow-shape": "triangle"}})
                temp_edge_selectors.append(color_key)
            cyto_edges.append(cyto_edge)

        stylesheet.append({
        'selector': ':selected',
        "style": {
            "background-color" : "white",
            "border-width": 2,
            "border-color": "black",
            "label": "data(label)",
            'z-index': 9999}})

        for shape in self.cyto_shapes:
            stylesheet.append({
                'selector': '.' + shape,
                'style': {'shape': shape}})

        self.elements = elements + cyto_nodes + cyto_edges
        figure = cyto.Cytoscape(
            id=graph_id,
            layout=layout,
            style={'width': f'{str(width)}vw', 'height': f'{str(height)}vh'},
            elements=self.elements,
            stylesheet = stylesheet,
            responsive=True)
        
        if legend:
            return figure,legend_dict
        return figure
    

    def _build_legend(self,node_colors=[],edge_colors=[],node_shapes=[],node_sizes=[]):
        legend_dict = {}
        f_node_colors = {}
        f_edge_colors = {}
        f_node_shapes = {}
        f_node_sizes = {}
        for node_color in node_colors:
            for k,v in node_color.items():
                f_node_colors[k] = v
        if len(f_node_colors) > 0:
            legend_dict["Node Color"] = f_node_colors

        for edge_color in edge_colors:
            for k,v in edge_color.items():
                f_edge_colors[k] = v
        if len(f_edge_colors) > 0:
            legend_dict["Edge Color"] = f_edge_colors

        for node_shape in node_shapes:
            for k,v in node_shape.items():
                f_node_shapes[k] = v
        if len(f_node_shapes) > 0:
            legend_dict["Node Shape"] = f_node_shapes

        for node_size in node_sizes:
            for k,v in node_size.items():
                f_node_sizes[k] = v
        if len(f_node_sizes) > 0:
            legend_dict["Node Size"] = f_node_sizes
        return legend_dict


    def _get_name(self,subject):
        split_subject = self._split(subject)
        if len(split_subject[-1]) == 1 and split_subject[-1].isdigit():
            return split_subject[-2]
        elif len(split_subject[-1]) == 3 and _isfloat(split_subject[-1]):
            return split_subject[-2]
        else:
            return split_subject[-1]

    def _split(self,uri):
        return re.split('#|\/|:', uri)
        
def _isfloat(x):
    try:
        float(x)
        return True
    except ValueError:
        return False